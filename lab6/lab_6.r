# УДАЛИТЬ ВСЕ ПЕРЕМЕННЫЕ
rm(list = ls.str())

# проверка версии приложения, языка....
# version

# двигатели машин
#data(mtcars)
#mtcars

# красные вина и их качество. последняя колонка - их оценка от 0 до 10
# ПОМЕНЯТЬ ПУТЬ К ФАЙЛУ!!!
wine_red <- read.csv(file = "F:/Кирилл/003 УНИВЕР/3 курс/004 2 семестр/big data/ЛР6/winequality-red.csv", header = TRUE, sep = ";", encoding = "UTF-8");wine_red
names <- c("Фиксированная кислотность", "Летучая кислотность", "Лимонная кислота",
           "Остаточный сахар", "Хлориды", "Cвободный диоксид серы",
           "Общий диоксид серы","Плотность","Показатель кислотности (pH)",
           "Сульфаты","Алкогольность","Оценка")

# СТОЛБЦЫ:
# 1 - Fixed acidity (фиксированная кислотность)
#  обусловлена наличием нелетучих кислот в
#  вине. Например, винная, лимонная или яблочная кислоты. Данный тип кислот
#  участвует в сбалансированности вкуса вина, привносит свежесть вкусу.

# 2 - Volatile acidity (Летучая кислотность)
#  та часть кислот в вине, которую можно уловить носом
#  В норме значения летучей кислотности (по нашему ГОСТу, в пересчете на уксусную кислоту)
#  должны быть не более, в г/дм3:
#     для белых и розовых вин - 1,10;
#     для красных - 1,20,
#  Летучие кислоты в законных концентрациях практически не участвуют в формировании вкуса вина, 
#  но активно вмешиваются в создание ароматики. Вместе со спиртами они образуют сложные эфиры с 
#  ароматом яблока, груши, ананаса, бананов, малины и других фруктов.


# 3 - citric acid (лимонная кислота)
#  лимонная кислота содержится только в очень малых количествах в винограде
#  Эта кислота, которую можно найти в составе многих ягодных, цитрусовых, применяется в 
#  тех случаях, когда уровень кислотности вина недостаточен. Это касается регионов с очень жарким климатом.

# 4 - residual sugar (остаточный сахар)
#  тот, что остался в вине после ферментации и выдержки. 
#  Это природный сахар, содержащийся в самом винограде.
#  На самом деле, многие вина в продуктовых обозначаются 
#  как «сухие», но при этом содержат 10 грамм остаточного сахара на литр. 
#  У заметно сладких вин этот показатель начинается от 35 грамм на литр и затем становится только выше.

# 5 - chlorides (хлориды)
#  хз, ничего не пишут про это нигде особо

# 6 - free sulfur dioxide (свободный диоксид серы)
#  используют в виноделии как консервант из-за его антиоксидантных и антимикробных свойств. 
#  Молекулярный SO2 является чрезвычайно эффективным антибиотиком, поражающим большинство микроорганизмов 
#  (в том числе дикие дрожжи), способных привести к порче вина.
#   Но, как вы понимаете, концентрация серы в вине совсем на другом уровне и нанести вред она может 
#  только тем людям, у которых есть индивидуальная чувствительность к этому газу

# 7 - total sulfur dioxide (общий диоксид серы)
#  

# 8 - density (плотность)
#  Плотность вина может быть как меньше, так и больше плотности воды. Ее значение определяется в 
#  первую очередь концентрацией спирта и сахара. Белые, розовые и красные вина, как правило, легче воды
#  Плотность и ее ощущение во вкусе зависит от количества сахара, алкоголя и глицерина. Глицерин в вине, 
#  несомненно — природного происхождения (меньшая его часть — просто из ягод, бОльшая — появляется
#  после вторичного брожения).

# 9 - pH (показатель кислотности вина)
#  Характеристика рН может выступать характеристикой цвета вина. Вина с
#  высоким pH темнее и имеют фиолетовый оттенок цвета. Вина с низким pH
#  светлее и имеют ярко-розовый и ярко-красный оттенок цвет
#  се вина в идеале имеют уровень рН от 2,9 до 4,2. Чем ниже рН, 
#  тем более кислое вино, чем выше рН, тем менее кислое вино.

# 10 - sulphates (сульфаты)
#  Сульфиты – это естественный результат жизнедеятельности дрожжей, 
#  сбраживающих сахар в вине в алкоголь. То есть - нельзя избежать присутствия сульфитов в вине.

# 11 - alcohol (алкогольность)

# 12 - quality (score between 0 and 10)

# судя по максимумам и минимумам по каждой переменной:
#   плотность у вин этой марки почти одинаковая, поэтому ее можно и не 
# учитывать при анализе (удалить нафиг);
#   показатель pH (уровень кислотности вина) тоже колеблется в пределах
# измерения 1 единицы, причем есть кислотность летучая (за запах отвечает)
# ее наверное лучше оставить, чтобы про запах тоже была одна переменная;
#   переменная quality (оценка) вообще, вероятно, здесь при кластерном
# анализе неуместна, так как будет сбивать с толку (хотя потом можно было
# бы добавить ееи посмотреть на кластеры с оценкой, как разделит)
#   в столбце chlorides есть выбросы (похоже в виде дешевого вина)
wine_red$density = NULL
wine_red$pH = NULL
wine_red$quality = NULL
wine_red
names <- c("Фиксированная кислотность", "Летучая кислотность", "Лимонная кислота",
           "Остаточный сахар", "Хлориды", "Cвободный диоксид серы",
           "Общий диоксид серы",
           "Сульфаты","Алкогольность")

maxes <- apply(wine_red, 2, max)
minims <- apply(wine_red, 2, min)
maxes
minims

# нормализуем (стандартизуем??) (данные-то разные "метрики" имеют)
wines <- scale(wine_red, center = minims, scale = maxes - minims)
wines

# Матрица попарных расстояний (по умолчанию - Евклидово расстояние)
dist_wines <- dist(wines)
dist_wines

# проводим кластерный анализ
clust_wines <- hclust(dist_wines, "ward.D") # кластеризация по методу Варда
clust_wines

# Построение дендрограммы
hcd <- as.dendrogram(clust_wines) # создадим но строить пока не будем
# так не надо, ничего же нипанятна
par(mfrow = c(1, 1))
plot(clust_wines,
     labels = rownames(wine_red), cex=0.5, 
     main="Дендрограмма кластеров",
     xlab="Экземпляры  вин")

# так получше, конечно
par(mfrow = c(3, 1))

plot(cut(hcd, h = 10)$upper,
     #labels = rownames(wine_red), cex=0.5, 
     main="Дендрограмма кластеров")

# ветка нижней части (Branch 12)
plot(cut(hcd, h = 10)$lower[[12]], 
     main = "Branch 12",
     xlab="Экземпляры  вин")
# ветка нижней части (Branch 5)
plot(cut(hcd, h = 10)$lower[[5]], 
     main = "Branch 5",
     xlab="Экземпляры  вин")

rect.hclust(clust_wines, k = 6, border = "blue")

# Разбиение дендрограммы на кластеры
# оценки - 3, 4, 5, ..., 8 => 6 кластеров образно говоря
groups <- cutree(clust_wines, k = 6)
groups

wines[groups==1, 1]
wines[groups==2, 1]
wines[groups==3, 1]
wines[groups==4, 1]
wines[groups==5, 1]
wines[groups==6, 1]
#wines[groups==7, 1]
#wines[groups==8, 1]

# Вычисляем среднее значение показателей в каждом кластере
g1<-colMeans(wines[groups==1,])
g2<-colMeans(wines[groups==2,])
g3<-colMeans(wines[groups==3,])
g4<-colMeans(wines[groups==4,])
g5<-colMeans(wines[groups==5,])
g6<-colMeans(wines[groups==6,])
#g7<-colMeans(wines[groups==7,])
#g8<-colMeans(wines[groups==8,])

# Построение столбчатой диаграммы
par(mfrow = c(1, 1))
df <- data.frame(g1,g2,g3,g4,g5,g6)
rownames(df) <- names
barplot(data.matrix(df),
        main="Группы вин",
        col=rainbow(9),
        ylim = c(0,0.7),
        beside = TRUE)
legend("topleft",
       names,
       col=rainbow(9),
       lwd=5,
       bty = "n",
       y.intersp = 1.0,
       cex=0.7)

# Ящики кластеров
boxplot(df)

# Каменная осыпь
plot(1:1598, clust_wines$height, type='b') 
# temp <- clust_wines$height # делал чтобы узнать кол-во переменных по иксу, почему-то их на 1 меньше... 1598, а не 1599


library(lattice)

# Двумерные диаграммы рассеяния
# Зависимость мощности двигателя от расхода
xyplot(fixed.acidity ~ alcohol, wine_red, main='Зависимость алкогольности вина \nот фиксированной кислотности',
       xlab='Фиксированная кислотность', ylab='алкогольность')

xyplot(fixed.acidity+volatile.acidity ~ alcohol, wine_red, auto.key = TRUE, main="Зависимость алкогольности вина от \nфиксированной и летучей кислотности",
       xlab="Алкогольность",
       ylab="фиксир. + летуч. кислотность")

####################################################
####################################################
# КЛАССИФИКАЦИЯ (лаб 6_2)
####################################################
####################################################
groups #разбитые по классам винишки

# Преобразование в фактор
groups_f <- factor(groups)

wines <- data.frame(wines)
wines <- cbind(wines, groups_f)

# Классификация по формуле Байеса
install.packages("klaR")
library(klaR)

# Вычисление вероятностей по всем признакам
naive_wines <- NaiveBayes(wines$groups_f ~ ., wines)
naive_wines$tables # 1 - средние значения, 2 - стандартное отклонение

# Ядерные функции плотности условной вероятности
plot(naive_wines,lwd = 2, legendplot=TRUE)

# Классификация по вероятностным данным (убрали кластеры)
predict <- predict(naive_wines, wines[,-10])$class

# Соотношение фактического расстояния и прогноза
table(Группа = wines$groups_f, Прогноз = predict)

# Вычисление точности классификации по формуле Байеса
accuracy_bayes <- mean(predict == wines$groups_f)
accuracy_bayes
paste("Точность=", round(100*accuracy_bayes, 2), "%", sep = "")

########################
# Деревья решений
########################
set.seed(1234) # для постоянства генератора случайных чисел


# Индексирование данных, для 1 вероятность 60%, для 2 - 40%
index <- sample(2, nrow(wines), replace=TRUE, prob=c(0.6, 0.4))

# разбиваем на две выборки - обучающую и тестовую
trainData <- wines[index==1,]
testData <- wines[index==2,]
nrow(trainData) # 983
nrow(testData)  # 616
nrow(wines)     # => 1599 (верно)

install.packages("party")
library(party)

# Построение модели
# Указываем зависимость групп от каждого параметра
formula <- groups_f ~ fixed.acidity + volatile.acidity + citric.acid + residual.sugar + chlorides + free.sulfur.dioxide + total.sulfur.dioxide + sulphates + alcohol
wines_ctree <- ctree(formula, trainData)

# Обучение модели
table(predict(wines_ctree), trainData$groups_f)

#очистка графика
dev.off()
# новое окно для графика
windows()
# чтобы адекватно увидеть это большое дерево, можно в новом окне его отрисовать
# или же сохранить как картинку, с параметрми хотя бы 6000х800
# весить PNG будет около 100 кБ

plot(wines_ctree,
     cex=0.2)

# Применение модели
test_predict <- predict(wines_ctree, newdata=testData)
table(test_predict, testData$groups_f)

# оценим точность
accuracy_tree <- mean(test_predict == testData$groups_f)
# всякие ненужные штуки для отображения (но раньше они мне пригодились)
#  length(testData$groups_f)
#  length(test_predict)
#  print(test_predict)
accuracy_tree
paste("Точность=", round(100*accuracy_tree, 2), "%", sep = "")

########################
# Случайный лес
########################
install.packages("randomForest")
library(randomForest)

# Обучение модели
forest <- randomForest(groups_f ~ .,trainData, ntree=15, proximity=TRUE)
table(predict(forest), trainData$groups_f)

# Применение на тестовой выборке
test_forest <- randomForest(groups_f ~ .,testData, ntree=15, proximity=TRUE)
table(predict(test_forest), testData$groups_f)

# просто на test forest не работал - это же модель по факту.... или я не понял?
accuracy_forest <- mean(predict(test_forest) == testData$groups_f)
accuracy_forest

# всякие ненужные штуки для отображения (но раньше они мне пригодились)
#  length(testData$groups_f)
#  length(test_forest)
#  print(test_forest)


